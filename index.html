<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Casino Poker â€” Advanced Texas Hold'em vs AI</title>
<style>
  :root{
    --table:#0b5a3a;
    --felt:#0b6b4a;
    --accent:#ffd700;
    --chip-red:#d9534f;
    --chip-blue:#337ab7;
    --chip-green:#5cb85c;
    --glass: rgba(255,255,255,0.06);
    --card-back: linear-gradient(135deg,#0b3,#036);
    font-family: Inter, "Segoe UI", Roboto, Arial, sans-serif;
  }
  html,body{height:100%;margin:0;background:radial-gradient(circle at 10% 10%, #07121a 0%, #000 60%);color:#eee}
  .container{display:flex;flex-direction:column;align-items:center;gap:18px;padding:18px}
  .table-wrap{width:100%;max-width:1100px;position:relative}
  .table{
    background:linear-gradient(180deg,var(--table),#063b2a);
    border-radius:18px;padding:28px;box-shadow:0 10px 40px rgba(0,0,0,0.7);
    position:relative;overflow:hidden;
  }
  .table:before{
    content:"";position:absolute;inset:0;border-radius:18px;
    background:radial-gradient(ellipse at center, rgba(255,255,255,0.02), transparent 30%);
    pointer-events:none;
  }
  .table-top{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
  .logo{display:flex;align-items:center;gap:12px}
  .logo .badge{background:var(--accent);color:#111;padding:6px 10px;border-radius:8px;font-weight:700}
  .controls{display:flex;gap:8px;align-items:center}
  .btn{background:var(--glass);border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:8px;color:#fff;cursor:pointer}
  .btn.primary{background:linear-gradient(180deg,#ffd54a,#ffb300);color:#111;border:none}
  .table-center{display:flex;flex-direction:column;align-items:center;gap:12px}
  .community{display:flex;gap:10px;align-items:center;min-height:120px}
  .card{width:90px;height:130px;border-radius:8px;background:#fff;color:#111;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:20px;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
  .card.back{background:linear-gradient(135deg,#0b3,#036);color:#fff}
  .player-row{display:flex;justify-content:space-between;align-items:flex-end;margin-top:18px}
  .player{width:48%;display:flex;flex-direction:column;gap:8px}
  .player .info{display:flex;justify-content:space-between;align-items:center}
  .chips{display:flex;gap:6px;align-items:center}
  .chip{width:44px;height:44px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;color:#fff;box-shadow:0 6px 12px rgba(0,0,0,0.5)}
  .chip.red{background:var(--chip-red)}
  .chip.blue{background:var(--chip-blue)}
  .chip.green{background:var(--chip-green)}
  .actions{display:flex;gap:8px;align-items:center}
  .bet-controls{display:flex;gap:8px;align-items:center;margin-top:8px}
  .bet-input{width:120px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.08);background:transparent;color:#fff}
  .log{max-height:160px;overflow:auto;background:rgba(0,0,0,0.3);padding:10px;border-radius:8px;font-size:13px}
  .status{display:flex;gap:12px;align-items:center}
  .pot{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:8px}
  .fancy{font-family:"Cinzel",serif}
  .card.small{width:60px;height:86px;font-size:14px}
  .hidden{display:none}
  /* responsive */
  @media(max-width:720px){
  .card{
    width:64px;
    height:92px;
    font-size:16px;
  }

  .card.small{
    width:52px;
    height:76px;
    font-size:13px;
  }

  .player-row{
    flex-direction:column;
    gap:12px;
  }
}

.card.flip-container {
  perspective: 1000px;
}

.card-inner {
  width: 100%;
  height: 100%;
  position: relative;
  transform-style: preserve-3d;
  transition: transform 0.7s ease;
}

.card.flip .card-inner {
  transform: rotateY(180deg);
}

.card-face {
  position: absolute;
  inset: 0;
  backface-visibility: hidden;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
}

.card-face.front {
  background: #fff;
  color: #111;
  transform: rotateY(180deg);
}

.card-face.back {
  background: var(--card-back);
  color: #fff;
}

    .player-row{flex-direction:column;gap:12px}
  }
</style>
</head>
<body>
<div class="container">
  <div class="table-wrap">
    <div class="table" id="table">
      <div class="table-top">
        <div class="logo">
          <div class="badge">CASINO</div>
          <div class="fancy">BCPoker</div>
        </div>
        <div class="controls">
          <div class="status">
            <div class="pot">Pot: <span id="potAmount">0</span></div>
            <div class="pot">Round: <span id="roundName">Idle</span></div>
          </div>
          <button class="btn" id="newGameBtn">New Game</button>
          <button class="btn" id="settingsBtn">Settings</button>
        </div>
      </div>

      <div class="table-center">
        <div class="community" id="community">
          <!-- community cards -->
        </div>
        <div class="player-row">
          <div class="player" id="aiPlayer">
            <div class="info">
              <div><strong>AI Opponent</strong></div>
              <div class="chips"><div class="chip red" id="aiChips">1000</div></div>
            </div>
            <div class="hand" id="aiHand">
              <!-- AI cards -->
            </div>
            <div class="log" id="aiLog">AI ready.</div>
          </div>

          <div class="player" id="humanPlayer">
            <div class="info">
              <div><strong>You</strong></div>
              <div class="chips"><div class="chip blue" id="humanChips">1000</div></div>
            </div>
            <div class="hand" id="humanHand">
              <!-- player cards -->
            </div>

            <div class="bet-controls">
              <input type="number" id="betInput" class="bet-input" value="10" min="1" />
              <div class="actions">
                <button class="btn" id="foldBtn">Fold</button>
                <button class="btn" id="callBtn">Call</button>
                <button class="btn primary" id="raiseBtn">Raise</button>
              </div>
            </div>

            <div class="log" id="gameLog">Welcome to Monte BC Poker.</div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <div style="max-width:1100px;width:100%;display:flex;justify-content:space-between;gap:12px">
    <div style="flex:1">
      <h4>Game Controls</h4>
      <p>Use the controls to bet. The AI uses BC poker to estimate win probability and plays accordingly.</p>
    </div>
    <div style="width:320px">
      <h4>Settings</h4>
      <div style="display:flex;flex-direction:column;gap:8px">
        <label>AI Simulation Iterations
          <input type="range" id="simIterations" min="100" max="5000" step="100" value="800" />
        </label>
        <label>Small Blind
          <input type="number" id="smallBlind" value="5" min="1" />
        </label>
        <label>Big Blind
          <input type="number" id="bigBlind" value="10" min="1" />
        </label>
      </div>
    </div>
  </div>
</div>

<script>
/* Advanced Texas Hold'em Implementation
   - Single HTML file
   - Game logic, hand evaluator, AI Monte Carlo
   - Designed for clarity and extensibility
*/

/* Utility functions */
const randInt = (n) => Math.floor(Math.random()*n);
const sleep = (ms) => new Promise(r=>setTimeout(r,ms));
const SUITS = ['â™ ','â™¥','â™¦','â™£'];
const RANKS = ['2','3','4','5','6','7','8','9','T','J','Q','K','A'];

/* Deck and card helpers */
function createDeck(){
  const deck = [];
  for(let s=0;s<4;s++){
    for(let r=0;r<13;r++){
      deck.push({rank:RANKS[r],suit:SUITS[s],code:RANKS[r]+SUITS[s],r:r});
    }
  }
  return deck;
}
function shuffle(deck){
  for(let i=deck.length-1;i>0;i--){
    const j = randInt(i+1);
    [deck[i],deck[j]]=[deck[j],deck[i]];
  }
  return deck;
}

/* Hand evaluator
   We'll implement a reasonably fast evaluator for 5-7 card hands.
   Approach: convert to numeric ranks, count occurrences, detect straights, flushes.
*/
function evaluateHand(cards){
  // cards: array of {rank,suit, r}
  // returns object {score, name, ranks:[]}
  const counts = {}; const suits = {};
  const ranks = cards.map(c=>c.r).sort((a,b)=>b-a);
  for(const c of cards){
    counts[c.r] = (counts[c.r]||0)+1;
    suits[c.suit] = (suits[c.suit]||0)+1;
  }
  // flush detection
  let flushSuit = null;
  for(const s in suits) if(suits[s]>=5) flushSuit = s;
  // straight detection (handle wheel A-2-3-4-5)
  const uniqueRanks = [...new Set(ranks)].sort((a,b)=>b-a);
  let straightHigh = null;
  for(let i=0;i<uniqueRanks.length;i++){
    let run = 1;
    let high = uniqueRanks[i];
    for(let j=i+1;j<uniqueRanks.length;j++){
      if(uniqueRanks[j]===uniqueRanks[j-1]-1) run++; else break;
    }
    let straightHigh = null;
for (let i = 0; i <= uniqueRanks.length - 5; i++) {
  let ok = true;
  for (let j = 1; j < 5; j++) {
    if (uniqueRanks[i + j] !== uniqueRanks[i] - j) {
      ok = false;
      break;
    }
  }
  if (ok) {
    straightHigh = uniqueRanks[i];
    break;
  }
}

  }
  // wheel check
  if(!straightHigh){
    const hasA = uniqueRanks.includes(12);
    const wheel = [3,2,1,0].every(v=>uniqueRanks.includes(v));
    if(hasA && wheel) straightHigh = 3; // 5-high straight
  }

  // flush + straight flush
  if(flushSuit){
    const flushCards = cards.filter(c=>c.suit===flushSuit).map(c=>c.r).sort((a,b)=>b-a);
    const uniqF = [...new Set(flushCards)];
    let sfHigh = null;
    for(let i=0;i<uniqF.length;i++){
      let run=1;
      for(let j=i+1;j<uniqF.length;j++){
        if(uniqF[j]===uniqF[j-1]-1) run++; else break;
      }
      let sfHigh = null;
for (let i = 0; i <= uniqF.length - 5; i++) {
  let ok = true;
  for (let j = 1; j < 5; j++) {
    if (uniqF[i + j] !== uniqF[i] - j) {
      ok = false;
      break;
    }
  }
  if (ok) {
    sfHigh = uniqF[i];
    break;
  }
}

    }
    if(!sfHigh){
      const hasA = uniqF.includes(12);
      const wheel = [3,2,1,0].every(v=>uniqF.includes(v));
      if(hasA && wheel) sfHigh = 3;
    }
    if(sfHigh!==null){
      // Straight flush or royal
      const score = 9000000 + sfHigh;
      return {score, name: sfHigh===12 ? 'Royal Flush' : 'Straight Flush', ranks:[sfHigh]};
    }
  }

  // counts analysis
  const byCount = {};
  for(const r in counts){
    const c = counts[r];
    byCount[c] = byCount[c] || [];
    byCount[c].push(parseInt(r));
  }
  for(const k in byCount) byCount[k].sort((a,b)=>b-a);

  // Four of a kind
  if(byCount[4] && byCount[4].length){
    const quad = byCount[4][0];
    const kicker = ranks.find(r=>r!==quad);
    const score = 8000000 + quad*100 + kicker;
    return {score, name:'Four of a Kind', ranks:[quad,kicker]};
  }
  // Full house
  if(byCount[3] && byCount[3].length){
    const trips = byCount[3][0];
    let pair = null;
    if(byCount[3].length>1) pair = byCount[3][1];
    else if(byCount[2] && byCount[2].length) pair = byCount[2][0];
    if(pair!==null){
      const score = 7000000 + trips*100 + pair;
      return {score, name:'Full House', ranks:[trips,pair]};
    }
  }
  // Flush
  if(flushSuit){
    const flushCards = cards.filter(c=>c.suit===flushSuit).map(c=>c.r).sort((a,b)=>b-a).slice(0,5);
    let score = 6000000;
    for(let i=0;i<flushCards.length;i++) score += flushCards[i]*Math.pow(10,4-i);
    return {score, name:'Flush', ranks:flushCards};
  }
  // Straight
  if(straightHigh!==null){
    const score = 5000000 + straightHigh;
    return {score, name:'Straight', ranks:[straightHigh]};
  }
  // Three of a kind
  if(byCount[3] && byCount[3].length){
    const trips = byCount[3][0];
    const kickers = ranks.filter(r=>r!==trips).slice(0,2);
    let score = 4000000 + trips*10000 + kickers[0]*100 + kickers[1];
    return {score, name:'Three of a Kind', ranks:[trips,...kickers]};
  }
  // Two pair
  if(byCount[2] && byCount[2].length>=2){
    const p1 = byCount[2][0], p2 = byCount[2][1];
    const kicker = ranks.find(r=>r!==p1 && r!==p2);
    let score = 3000000 + p1*10000 + p2*100 + kicker;
    return {score, name:'Two Pair', ranks:[p1,p2,kicker]};
  }
  // One pair
  if(byCount[2] && byCount[2].length===1){
    const p = byCount[2][0];
    const kickers = ranks.filter(r=>r!==p).slice(0,3);
    let score = 2000000 + p*1000000 + kickers[0]*10000 + kickers[1]*100 + kickers[2];
    return {score, name:'One Pair', ranks:[p,...kickers]};
  }
  // High card
  const top5 = ranks.slice(0,5);
  let score = 1000000;
  for(let i=0;i<top5.length;i++) score += top5[i]*Math.pow(10,4-i);
  return {score, name:'High Card', ranks:top5};
}

/* Compare two hands given community cards */
function bestHandFromHole(hole, community){
  const all = hole.concat(community);
  // choose best 5-card combination from all (nC5)
  let best = null;
  const n = all.length;
  const idx = [...Array(n).keys()];
  function comb(arr,k,start,cur){
    if(cur.length===k){
      const evalRes = evaluateHand(cur);
      if(!best || evalRes.score>best.score) best = evalRes;
      return;
    }
    for(let i=start;i<arr.length;i++){
      comb(arr,k,i+1,cur.concat([arr[i]]));
    }
  }
  comb(all,5,0,[]);
  return best;
}

/* Game state and logic */



const state = {
  deck:[],
  community:[],
  players:[
    {name:'AI',chips:1000,hand:[],active:true,bet:0,folded:false},
    {name:'You',chips:1000,hand:[],active:true,bet:0,folded:false}
  ],
  dealer:0,
  pot:0,
  sidePots:[],
  currentBet:0,
  lastAggressor: null, // 0 = AI, 1 = Human
  turn:1,
  round:'idle',
  smallBlind:5,
  bigBlind:10,
  simIterations:800,
  minRaise:10,

  memory: {
    handsPlayed: 0,
    human: {
      folds: 0,
      calls: 0,
      raises: 0,
      aggression: 0.5,
      lastShowdown: null
    },
    ai: {
      bluffs: 0,
      bluffSuccess: 0,
      lastResult: null
    }
  }
};


/* UI helpers */
const el = (id)=>document.getElementById(id);
function renderChips(){
  el('aiChips').textContent = state.players[0].chips;
  el('humanChips').textContent = state.players[1].chips;
  el('potAmount').textContent = state.pot;
}
function log(msg, who='game'){
  const target = who==='ai' ? el('aiLog') : el('gameLog');
  const time = new Date().toLocaleTimeString();
  target.innerHTML = `<div>[${time}] ${msg}</div>` + target.innerHTML;
}
function renderHands(revealAI = false, animate = false) {
  const aiHandEl = el('aiHand'); aiHandEl.innerHTML = '';
  const humanHandEl = el('humanHand'); humanHandEl.innerHTML = '';

  // --- AI cards ---
  for (const c of state.players[0].hand) {
    const container = document.createElement('div');
    container.className = 'card small flip-container';
    if (revealAI && animate) container.classList.add('flip');

    const inner = document.createElement('div');
    inner.className = 'card-inner';

    const back = document.createElement('div');
    back.className = 'card-face back';
    back.textContent = 'ðŸ‚ ';

    const front = document.createElement('div');
    front.className = 'card-face front';
    front.textContent = c.code;

    inner.appendChild(back);
    inner.appendChild(front);
    container.appendChild(inner);
    aiHandEl.appendChild(container);

    // force reflow so animation triggers
    if (revealAI && animate) {
      requestAnimationFrame(() => container.classList.add('flip'));
    }
  }

  // --- Human cards (always face-up, no flip) ---
  for (const c of state.players[1].hand) {
    const d = document.createElement('div');
    d.className = 'card small';
    d.textContent = c.code;
    humanHandEl.appendChild(d);
  }
}

function renderCommunity(){
  const cont = el('community'); cont.innerHTML='';
  for(const c of state.community){
    const d = document.createElement('div'); d.className='card';
    d.textContent = c.code;
    cont.appendChild(d);
  }
}

/* Game flow functions */
function resetDeck(){
  state.deck = shuffle(createDeck());
}
function dealHole(){
  for(let p of state.players) p.hand = [];
  // deal two to each
  for(let i=0;i<2;i++){
    for(let p of state.players){
      p.hand.push(state.deck.pop());
    }
  }
}
function postBlinds(){
  const sb = state.smallBlind, bb = state.bigBlind;
  const sbPlayer = (state.dealer+1)%2;
  const bbPlayer = (state.dealer+2)%2;
  // ensure indices map to players array length 2
  const sbIdx = sbPlayer%2, bbIdx = bbPlayer%2;
  const sbAmt = Math.min(sb, state.players[sbIdx].chips);
  state.players[sbIdx].chips -= sbAmt; state.players[sbIdx].bet += sbAmt; state.pot += sbAmt;
  const bbAmt = Math.min(bb, state.players[bbIdx].chips);
  state.players[bbIdx].chips -= bbAmt; state.players[bbIdx].bet += bbAmt; state.pot += bbAmt;
  state.currentBet = bbAmt;
  log(`${state.players[sbIdx].name} posts small blind ${sbAmt}`, sbIdx===0?'ai':'game');
  log(`${state.players[bbIdx].name} posts big blind ${bbAmt}`, bbIdx===0?'ai':'game');
  renderChips();
}
function startHand(){
  // reset
  state.community = [];
  state.pot = 0;
  state.sidePots = [];
  state.currentBet = 0;
  state.players.forEach(p=>{p.bet=0;p.folded=false;p.active=true;});
  resetDeck();
  dealHole();
  renderHands(false);
  renderCommunity();
  postBlinds();
  state.round = 'preflop';
  el('roundName').textContent = 'Preflop';
  // first to act is player after big blind
  state.turn = (state.dealer+3)%2; // small table mapping
  log('New hand started.');
  // if AI acts first, trigger AI turn
  if(state.turn===0) aiAct();
}
async function progressRound(){
  // advance round: preflop -> flop -> turn -> river -> showdown
  if(state.round==='preflop'){
    // burn one, deal 3
    state.deck.pop(); state.community.push(state.deck.pop(),state.deck.pop(),state.deck.pop());
    state.round='flop'; el('roundName').textContent='Flop';
  } else if(state.round==='flop'){
    state.deck.pop(); state.community.push(state.deck.pop()); state.round='turn'; el('roundName').textContent='Turn';
  } else if(state.round==='turn'){
    state.deck.pop(); state.community.push(state.deck.pop()); state.round='river'; el('roundName').textContent='River';
  } else if(state.round==='river'){
    state.round='showdown'; el('roundName').textContent='Showdown';
    await showdown();
    return;
  }
  // reset bets for next betting round
  state.players.forEach(p=>p.bet=0);
  state.currentBet=0;
  renderCommunity();
  renderHands(false);
  // first to act is player after dealer (small blind) -> for 2 players, it's dealer^1
  state.turn = (state.dealer+1)%2;
  log(`Dealt ${state.round}.`);
  if(state.turn===0) aiAct();
}

/* Betting helpers */
function getOther(i){ return (i+1)%2; }
function canContinueBetting(){
  // if both players have equal bets or one folded, betting round can end
  const activePlayers = state.players.filter(p=>!p.folded && p.chips>0);
  if(activePlayers.length<=1) return false;
  // if bets equal and no pending raises, end
  const bets = state.players.map(p=>p.bet);
  return !(bets[0]===bets[1]);
}

/* Showdown and pot resolution */
async function showdown(){
  // reveal AI hand
  renderHands(true, true);
await sleep(900); // let the flip animation play

  log('Showdown: revealing hands.');
  // evaluate both
  const aiBest = bestHandFromHole(state.players[0].hand, state.community);
  const humanBest = bestHandFromHole(state.players[1].hand, state.community);
  log(`AI: ${aiBest.name}`, 'ai');
  log(`You: ${humanBest.name}`, 'game');
  // compare scores
  if(aiBest.score > humanBest.score){
    state.players[0].chips += state.pot;
    log(`AI wins pot ${state.pot}`, 'ai');
  } else if(aiBest.score < humanBest.score){
    state.players[1].chips += state.pot;
    log(`You win pot ${state.pot}`, 'game');
  } else {
    // tie split
    const half = Math.floor(state.pot/2);
    state.players[0].chips += half;
    state.players[1].chips += state.pot-half;
    log(`Split pot ${state.pot}`, 'game');
  }
  state.pot = 0;
  renderChips();
  
  state.memory.handsPlayed++;

if (aiBest.score > humanBest.score) {
  state.memory.ai.lastResult = 'win';
  state.memory.human.lastShowdown = 'loss';
} else if (aiBest.score < humanBest.score) {
  state.memory.ai.lastResult = 'loss';
  state.memory.human.lastShowdown = 'win';
} else {
  state.memory.ai.lastResult = 'tie';
  state.memory.human.lastShowdown = 'tie';
}

  // rotate dealer
  state.dealer = getOther(state.dealer);
  await sleep(1200);
  renderHands(false);
  el('roundName').textContent = 'Idle';
}

/* AI decision making
   We'll use a Monte Carlo simulation to estimate win probability:
   - For each iteration: simulate random remaining deck, deal remaining community cards, evaluate winner.
   - Use heuristics for betting: if winProb high -> raise; medium -> call; low -> fold or bluff.
*/
function preflopHandStrength(hand){
  const r1 = hand[0].r;
  const r2 = hand[1].r;
  const suited = hand[0].suit === hand[1].suit;
  const high = Math.max(r1, r2);
  const low = Math.min(r1, r2);

  // Pairs
  if (r1 === r2) {
    if (r1 >= 10) return 0.95;   // TT+
    if (r1 >= 7)  return 0.85;   // 77â€“99
    return 0.65;                 // small pairs
  }

  // Big cards
  if (high >= 11 && low >= 9) return suited ? 0.8 : 0.7; // AK, AQ, KQ
  if (high >= 11) return suited ? 0.65 : 0.55;

  // Suited connectors
  if (suited && high - low === 1 && high >= 7) return 0.6;

  // Trash
  return 0.35;
}

function potOdds(toCall){
  return toCall / (state.pot + toCall);
}

function clamp(val, min, max){
  return Math.max(min, Math.min(max, val));
}


async function aiAct(){
  const ai = state.players[0];
  const human = state.players[1];
  if (ai.folded) return;

  log('AI is thinking...', 'ai');
  await sleep(600 + randInt(600));

  const toCall = state.currentBet - ai.bet;
  const stack = ai.chips;
  const pot = state.pot;

 let winProb;

// --- PREFLOP vs POSTFLOP ---
if (state.round === 'preflop') {
  winProb = preflopHandStrength(ai.hand);
} else {
  winProb = estimateWinProbability(
    ai.hand,
    state.community,
    state.deck,
    state.simIterations
  );
}

// --- MEMORY ADJUSTMENT ---
const humanAggro = state.memory.human.aggression;
if (humanAggro > 0.65) winProb += 0.05;
if (humanAggro < 0.35) winProb -= 0.05;
winProb = clamp(winProb, 0, 1);


 
  // --- PREFLOP: use hand table ---
  if (state.round === 'preflop') {
    winProb = preflopHandStrength(ai.hand);
  } else {
    winProb = estimateWinProbability(
      ai.hand,
      state.community,
      state.deck,
      state.simIterations
    );
  }

  const odds = toCall > 0 ? potOdds(toCall) : 0;
  const committed = ai.bet > 0;
  const inPosition = state.turn === 0; // AI acts second post-flop in HU

  // --- DECISION ---
  let action = 'call';
  let raiseSize = 0;

  // STRONG HAND
  if (winProb > 0.72) {
    action = 'raise';
    raiseSize = clamp(
      Math.floor(pot * (0.6 + winProb)),
      state.bigBlind,
      stack
    );
  }

  // MEDIUM HAND
  else if (winProb > 0.5) {
    if (toCall === 0) {
      action = Math.random() < 0.6 ? 'raise' : 'check';
      raiseSize = clamp(Math.floor(pot * 0.4), state.bigBlind, stack);
    } else {
      action = winProb > odds ? 'call' : 'fold';
    }
  }

  // WEAK HAND
  else {
    const bluffFreq = clamp(
  0.1 + (humanAggro - 0.5) * 0.3,
  0.05,
  0.35
);

if (toCall === 0 && inPosition && Math.random() < bluffFreq) {

      // small positional bluff
      action = 'raise';
      raiseSize = clamp(Math.floor(pot * 0.3), state.bigBlind, stack);
      log('AI probes with a small bluff.', 'ai');
    } else {
      action = committed && winProb > odds * 0.8 ? 'call' : 'fold';
    }
  }

  // --- EXECUTION ---
  if (action === 'fold') {
  state.memory.ai.bluffs++;
  state.memory.ai.bluffSuccess++;
  
    ai.folded = true;
    log('AI folds.', 'ai');
    human.chips += pot;
    state.pot = 0;
    renderChips();
    state.dealer = getOther(state.dealer);
    el('roundName').textContent = 'Idle';
    return;
  }

  if (action === 'call' || action === 'check') {
    const amt = Math.min(toCall, stack);
    ai.chips -= amt;
    ai.bet += amt;
    state.pot += amt;
    log(action === 'check' ? 'AI checks.' : `AI calls ${amt}.`, 'ai');
    renderChips();
  }

  if (action === 'raise') {
  const total = Math.min(stack, toCall + raiseSize);
  ai.chips -= total;
  ai.bet += total;
  state.pot += total;
  state.currentBet = ai.bet;
  state.lastAggressor = 0; // AI
  log(`AI raises to ${state.currentBet}.`, 'ai');
  renderChips();
}


  // --- ROUND CONTROL ---
  if (!canContinueBetting()) {
    await sleep(400);
    await progressRound();
  } else {
    state.turn = 1;
  }
}


/* Estimate win probability via Monte Carlo */
function estimateWinProbability(hole, community, deck, iterations=800){
  // quick deterministic checks for trivial cases
  if(community.length===5){
    // evaluate directly
    const aiBest = bestHandFromHole(hole, community);
    // simulate opponent random hole
    let wins=0, ties=0;
    const deckCopy = deck.slice();
    for(let i=0;i<iterations;i++){
      shuffle(deckCopy);
      const oppHole = [deckCopy[0], deckCopy[1]];
      const oppBest = bestHandFromHole(oppHole, community);
      if(aiBest.score > oppBest.score) wins++;
      else if(aiBest.score === oppBest.score) ties++;
    }
    return (wins + ties*0.5)/iterations;
  }
  // Monte Carlo: sample random opponent hands and remaining community
  let wins=0, ties=0;
  const deckBase = deck.slice();
  for(let it=0; it<iterations; it++){
    const d = deckBase.slice();
    shuffle(d);
    // draw opponent hole
    const oppHole = [d.pop(), d.pop()];
    // draw remaining community
    const needed = 5 - community.length;
    const simCommunity = community.slice();
    for(let k=0;k<needed;k++) simCommunity.push(d.pop());
    const aiBest = bestHandFromHole(hole, simCommunity);
    const oppBest = bestHandFromHole(oppHole, simCommunity);
    if(aiBest.score > oppBest.score) wins++;
    else if(aiBest.score === oppBest.score) ties++;
  }
  return (wins + ties*0.5)/iterations;
}

/* Player actions */
function updateAggression(){
  const h = state.memory.human;
  const total = h.folds + h.calls + h.raises;
  if (total === 0) return;

  // weighted: raises count more
  h.aggression = clamp(
    (h.raises * 1.2 + h.calls * 0.6) / total,
    0,
    1
  );
}


async function playerFold(){
  state.players[1].folded = true;
  state.memory.human.folds++;
  updateAggression();
  log('You fold.', 'game');
  await endHand('fold', 0); // AI wins
}


function updateCallButton(){
  const toCall = state.players[0].bet - state.players[1].bet;
  el('callBtn').textContent = toCall > 0 ? `Call ${toCall}` : 'Check';
}

async function endHand(reason, winnerIdx = null) {
  // Reveal AI cards every time a hand ends
  renderHands(true, true);
  await sleep(900);

  if (reason === 'fold') {
    log(`${state.players[winnerIdx].name} wins (opponent folded).`, winnerIdx === 0 ? 'ai' : 'game');
    state.players[winnerIdx].chips += state.pot;
  }

  if (reason === 'showdown') {
    const aiBest = bestHandFromHole(state.players[0].hand, state.community);
    const humanBest = bestHandFromHole(state.players[1].hand, state.community);

    log(`AI: ${aiBest.name}`, 'ai');
    log(`You: ${humanBest.name}`, 'game');

    if (aiBest.score > humanBest.score) {
      state.players[0].chips += state.pot;
      log(`AI wins pot ${state.pot}`, 'ai');
    } else if (aiBest.score < humanBest.score) {
      state.players[1].chips += state.pot;
      log(`You win pot ${state.pot}`, 'game');
    } else {
      const half = Math.floor(state.pot / 2);
      state.players[0].chips += half;
      state.players[1].chips += state.pot - half;
      log(`Split pot ${state.pot}`, 'game');
    }
  }

  state.pot = 0;
  renderChips();

  state.dealer = getOther(state.dealer);
  state.round = 'idle';
  el('roundName').textContent = 'Idle';

  await sleep(1200);
  renderHands(false);
}


async function playerCall(){
  state.memory.human.calls++;
  updateAggression();

  const me = state.players[1];
  const opp = state.players[0];

  const toCall = Math.max(0, opp.bet - me.bet);
  const callAmt = Math.min(toCall, me.chips);

  if (callAmt === 0) {
    log('You check.', 'game');
  } else {
    me.chips -= callAmt;
    me.bet += callAmt;
    state.pot += callAmt;
    log(`You call ${callAmt}.`, 'game');
  }

  renderChips();

  if (!canContinueBetting()) {
    await sleep(400);
    await progressRound();
  } else {
    state.turn = 0;
    aiAct();
  }
}

async function playerRaise(){
  state.memory.human.raises++;
  updateAggression();
  state.currentBet = state.players[1].bet;
state.lastAggressor = 1; // Human
  
  const raiseVal = Math.max(parseInt(el('betInput').value||0), state.minRaise);
  const toCall = state.currentBet - state.players[1].bet;
  const total = Math.min(state.players[1].chips, toCall + raiseVal);
  state.players[1].chips -= total; state.players[1].bet += total; state.pot += total;
  state.currentBet = state.players[1].bet;
  log(`You raise to ${state.currentBet}.`, 'game');
  renderChips();
  // AI turn
  state.turn = 0;
  aiAct();
}

/* UI event wiring */
el('foldBtn').addEventListener('click', ()=>{ if(state.round==='idle') return; playerFold(); });
el('callBtn').addEventListener('click', ()=>{ if(state.round==='idle') return; playerCall(); });
el('raiseBtn').addEventListener('click', ()=>{ if(state.round==='idle') return; playerRaise(); });
el('newGameBtn').addEventListener('click', ()=>{
  state.players[0].chips = 1000;
  state.players[1].chips = 1000;
  state.dealer = Math.random()<0.5?0:1;

  

  renderChips();
  startHand();
});

el('settingsBtn').addEventListener('click', ()=>{ alert('Adjust settings on the right panel.'); });
el('simIterations').addEventListener('input', (e)=>{ state.simIterations = parseInt(e.target.value); });
el('smallBlind').addEventListener('input', (e)=>{ state.smallBlind = parseInt(e.target.value); });
el('bigBlind').addEventListener('input', (e)=>{ state.bigBlind = parseInt(e.target.value); });

/* Initialize UI */
renderChips();
renderHands(false);
renderCommunity();
el('roundName').textContent = 'Idle';

/* Start a first hand automatically */
startHand();

</script>
</body>
</html>
