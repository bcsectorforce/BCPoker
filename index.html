<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Advanced Texas Hold'em â€” AI Opponents</title>
<style>
:root{
  --bg:#07121a; --felt:#0b6b4a; --panel:#0b3a2b; --accent:#ffd54a;
  --text:#eaeaea; --muted:#bfc9c2; --danger:#d9534f;
  font-family: Inter, "Segoe UI", Roboto, Arial, sans-serif;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:radial-gradient(circle at 10% 10%, #07121a 0%, #000 60%);color:var(--text)}
.container{max-width:1200px;margin:18px auto;padding:18px;display:grid;grid-template-columns:1fr 360px;gap:18px}
.table-wrap{background:linear-gradient(180deg,var(--felt),#063b2a);border-radius:14px;padding:18px;box-shadow:0 12px 40px rgba(0,0,0,0.6)}
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
.brand{display:flex;align-items:center;gap:12px}
.badge{background:var(--accent);color:#111;padding:6px 10px;border-radius:8px;font-weight:700}
.controls{display:flex;gap:8px;align-items:center}
.btn{background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:8px;color:var(--text);cursor:pointer}
.btn.primary{background:linear-gradient(180deg,#ffd54a,#ffb300);color:#111;border:none}
.table-center{display:flex;flex-direction:column;align-items:center;gap:12px}
.community{display:flex;gap:10px;min-height:120px;align-items:center}


.card-wrap{
  perspective: 800px;
  width:64px;
  height:92px;
}


.card-inner{
  width:100%;
  height:100%;
  position:relative;
  transform-style:preserve-3d;
  transition: transform 0.6s ease;
}

.card-wrap.revealed .card-inner{
  transform: rotateY(180deg);
}

.card-face{
  position:absolute;
  width:100%;
  height:100%;
  backface-visibility:hidden;
  border-radius:10px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:700;
  box-shadow:0 6px 18px rgba(0,0,0,0.6);
}

.card-front{
  background:#fff;
  color:#111;
  transform: rotateY(180deg);
}

.card-back{
  background:linear-gradient(135deg,#0b3,#036);
  color:#fff;
}

.card{width:90px;height:130px;border-radius:10px;background:#fff;color:#111;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:20px;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
.card.small{width:64px;height:92px;font-size:16px}
.card.back{background:linear-gradient(135deg,#0b3,#036);color:#fff}
.player-row{display:flex;gap:12px;flex-wrap:wrap;justify-content:center}
.player{width:220px;background:rgba(0,0,0,0.12);padding:10px;border-radius:10px;display:flex;flex-direction:column;gap:8px;align-items:center}
.player .info{display:flex;justify-content:space-between;width:100%}
.chips{display:flex;gap:6px;align-items:center}
.chip{width:48px;height:28px;border-radius:6px;background:var(--panel);display:flex;align-items:center;justify-content:center;color:var(--text);font-weight:700}
.log{max-height:220px;overflow:auto;background:rgba(0,0,0,0.25);padding:10px;border-radius:8px;font-size:13px;color:var(--muted)}
.side-panel{background:linear-gradient(180deg,#0b2b1f,#062a1f);padding:12px;border-radius:12px;color:var(--muted)}
.setting{display:flex;flex-direction:column;gap:6px;margin-bottom:8px}
.range{width:100%}
.status{display:flex;gap:12px;align-items:center}
.pot{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:8px}
.controls-bottom{display:flex;gap:8px;align-items:center;margin-top:8px}
.input{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--text);width:120px}
.small{font-size:12px;color:var(--muted)}
.hud{display:flex;gap:8px;align-items:center}
.progress{height:8px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;width:100%}
.progress > i{display:block;height:100%;background:linear-gradient(90deg,#ffd54a,#ffb300)}
.footer{margin-top:12px;color:var(--muted);font-size:13px}
@media(max-width:980px){.container{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="container">
  <div class="table-wrap">
    <div class="header">
      <div class="brand">
        <div class="badge">CASINO</div>
        <div style="font-family:Cinzel,serif;font-weight:700">BCPoker Pro</div>
      </div>
      <div class="controls">
        <div class="status">
          <div class="pot">Pot: <strong id="potAmount">0</strong></div>
          <div class="pot">Round: <strong id="roundName">Idle</strong></div>
        </div>
        <button class="btn" id="newGameBtn">New Game</button>
        <button class="btn" id="settingsBtn">Settings</button>
      </div>
    </div>

    <div class="table-center">
      <div class="community" id="community"></div>

      <div class="player-row" id="playerRow"></div>

      <div style="width:100%;display:flex;justify-content:space-between;align-items:center;margin-top:8px">
        <div style="flex:1">
          <div class="controls-bottom">
            <input id="betInput" class="input" type="number" min="1" value="20" />
            <button class="btn" id="foldBtn">Fold</button>
            <button class="btn" id="callBtn">Call</button>
            <button class="btn primary" id="raiseBtn">Raise</button>
            <div style="margin-left:12px" class="small">Time left: <span id="turnTimer">â€”</span>s</div>
          </div>
        </div>
        <div style="width:320px;margin-left:12px">
          <div class="log" id="gameLog">Welcome to Advanced BC Poker.</div>
        </div>
      </div>
    </div>

    <div class="footer small">Tip: adjust AI difficulty and simulation iterations in the right panel for different experiences.</div>
  </div>

  <div class="side-panel">
    <h4 style="margin:0 0 8px 0;color:var(--text)">Settings & Stats</h4>

    <div class="setting">
      <label class="small">Players (including you)</label>
      <select id="playerCount">
        <option value="2">2 (Heads-up)</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
      </select>
    </div>

    <div class="setting">
      <label class="small">AI Difficulty</label>
      <select id="aiDifficulty">
        <option value="0.6">Easy</option>
        <option value="0.8" selected>Normal</option>
        <option value="1.0">Hard</option>
      </select>
    </div>

    <div class="setting">
      <label class="small">AI Simulation Iterations: <span id="simLabel">1200</span></label>
      <input id="simIterations" class="range" type="range" min="200" max="5000" step="100" value="1200" />
    </div>

    <div class="setting">
      <label class="small">Small Blind</label>
      <input id="smallBlind" class="input" type="number" value="5" min="1" />
    </div>

    <div class="setting">
      <label class="small">Big Blind</label>
      <input id="bigBlind" class="input" type="number" value="10" min="1" />
    </div>

    <div style="margin-top:12px">
      <h5 style="margin:0 0 6px 0;color:var(--text)">Session Stats</h5>
      <div class="small">Hands played: <span id="handsPlayed">0</span></div>
      <div class="small">Your net: <span id="yourNet">0</span></div>
      <div class="small">AI wins: <span id="aiWins">0</span></div>
    </div>
  </div>
</div>

<script>
/* -------------------------
   Utilities & Constants
   ------------------------- */
const SUITS = ['â™ ','â™¥','â™¦','â™£'];
const RANKS = ['2','3','4','5','6','7','8','9','T','J','Q','K','A'];
const RANK_TO_VALUE = RANKS.reduce((m,r,i)=>{m[r]=i;return m},{});
const randInt = n => Math.floor(Math.random()*n);
const sleep = ms => new Promise(r=>setTimeout(r,ms));
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

/* -------------------------
   Deck & Card Helpers
   ------------------------- */
function createDeck(){
  const deck=[];
  for(let s=0;s<4;s++){
    for(let r=0;r<13;r++){
      deck.push({rank:RANKS[r],suit:SUITS[s],v:r,code:RANKS[r]+SUITS[s]});
    }
  }
  return deck;
}
function shuffle(deck){
  for(let i=deck.length-1;i>0;i--){
    const j=randInt(i+1);
    [deck[i],deck[j]]=[deck[j],deck[i]];
  }
  return deck;
}

/* -------------------------
   Hand Evaluator (robust)
   - returns numeric score and descriptive name
   - score: higher is better; includes tie-breakers
   ------------------------- */
function evaluate7(cards){
  // cards: array of {v, suit, rank}
  // Convert to counts
  const counts = new Array(13).fill(0);
  const suits = {'â™ ':[],'â™¥':[],'â™¦':[],'â™£':[]};
  for(const c of cards){ counts[c.v]++; suits[c.suit].push(c.v); }
  // helper to find best straight in a sorted unique array
  const unique = [];
  for(let i=12;i>=0;i--) if(counts[i]) unique.push(i);
  // Ace-low handling: add -1 as 12->-1 mapping for wheel detection
  const uniqWithAceLow = unique.slice();
  if(unique.includes(12)) uniqWithAceLow.push(-1); // treat A as low for wheel
  function findStraight(arr){
    if(arr.length<5) return null;
    let run=1, best=arr[0];
    for(let i=1;i<arr.length;i++){
      if(arr[i]===arr[i-1]-1){ run++; if(run>=5) { best=arr[i-4]; } }
      else run=1;
    }
    // find highest straight high value
    for(let i=0;i<=arr.length-5;i++){
      let ok=true;
      for(let j=1;j<5;j++) if(arr[i+j]!==arr[i]-j) { ok=false; break; }
      if(ok) return arr[i];
    }
    return null;
  }
  const straightHigh = findStraight(uniqWithAceLow);
  // flush detection
  let flushSuit=null;
  for(const s of SUITS) if(suits[s].length>=5) flushSuit=s;
  // straight flush
  if(flushSuit){
    const fs = suits[flushSuit].slice().sort((a,b)=>b-a);
    const fsUniq = [...new Set(fs)];
    const sfHigh = findStraight(fsUniq.concat(fsUniq.includes(12)?[-1]:[]));
    if(sfHigh!==null){
      if(sfHigh===12) return {score:9000000, name:'Royal Flush', ranks:[12]};
      return {score:9000000 + sfHigh, name:'Straight Flush', ranks:[sfHigh]};
    }
  }
  // counts map
  const byCount = {};
  for(let i=12;i>=0;i--){
    const c = counts[i];
    if(c>0){ byCount[c]=byCount[c]||[]; byCount[c].push(i); }
  }
  // Four of a kind
  if(byCount[4] && byCount[4].length){
    const quad = byCount[4][0];
    const kicker = (()=>{ for(let i=12;i>=0;i--) if(i!==quad && counts[i]) return i; })();
    return {score:8000000 + quad*100 + kicker, name:'Four of a Kind', ranks:[quad,kicker]};
  }
  // Full house
  if((byCount[3] && byCount[3].length) || (byCount[2] && byCount[2].length)){
    const trips = (byCount[3] && byCount[3].length)?byCount[3][0]:null;
    let pair = null;
    if(byCount[3] && byCount[3].length>1) pair = byCount[3][1];
    else if(byCount[2] && byCount[2].length) pair = byCount[2][0];
    if(trips!==null && pair!==null) return {score:7000000 + trips*100 + pair, name:'Full House', ranks:[trips,pair]};
  }
  // Flush
  if(flushSuit){
    const top5 = suits[flushSuit].slice().sort((a,b)=>b-a).slice(0,5);
    let score = 6000000;
    for(let i=0;i<top5.length;i++) score += top5[i]*Math.pow(100,4-i);
    return {score, name:'Flush', ranks:top5};
  }
  // Straight
  if(straightHigh!==null) return {score:5000000 + straightHigh, name:'Straight', ranks:[straightHigh]};
  // Three of a kind
  if(byCount[3] && byCount[3].length){
    const trips = byCount[3][0];
    const kickers = [];
    for(let i=12;i>=0 && kickers.length<2;i--) if(i!==trips && counts[i]) kickers.push(i);
    let score = 4000000 + trips*10000 + kickers[0]*100 + kickers[1];
    return {score, name:'Three of a Kind', ranks:[trips,...kickers]};
  }
  // Two pair
  if(byCount[2] && byCount[2].length>=2){
    const p1 = byCount[2][0], p2 = byCount[2][1];
    const kicker = (()=>{ for(let i=12;i>=0;i--) if(i!==p1 && i!==p2 && counts[i]) return i; })();
    let score = 3000000 + p1*10000 + p2*100 + kicker;
    return {score, name:'Two Pair', ranks:[p1,p2,kicker]};
  }
  // One pair
  if(byCount[2] && byCount[2].length===1){
    const p = byCount[2][0];
    const kickers=[];
    for(let i=12;i>=0 && kickers.length<3;i--) if(i!==p && counts[i]) kickers.push(i);
    let score = 2000000 + p*1000000 + kickers[0]*10000 + kickers[1]*100 + kickers[2];
    return {score, name:'One Pair', ranks:[p,...kickers]};
  }
  // High card
  const top5=[];
  for(let i=12;i>=0 && top5.length<5;i--) if(counts[i]) top5.push(i);
  let score = 1000000;
  for(let i=0;i<top5.length;i++) score += top5[i]*Math.pow(100,4-i);
  return {score, name:'High Card', ranks:top5};
}

/* -------------------------
   Best 5 from hole + community
   ------------------------- */
function bestFrom(hole, community){
  const all = hole.concat(community);
  // choose best 5-of-n combination (n up to 7)
  let best = null;
  const n = all.length;
  const idx = Array.from({length:n},(_,i)=>i);
  function comb(start, chosen){
    if(chosen.length===5){
      const res = evaluate7(chosen);
      if(!best || res.score>best.score) best = res;
      return;
    }
    for(let i=start;i<n;i++) comb(i+1, chosen.concat(all[i]));
  }
  comb(0,[]);
  return best;
}

/* -------------------------
   Game State & Engine
   ------------------------- */
const state = {
  deck:[],
  community:[],
  players:[], // {id,name,ai,stack,hand,bet,folded,allIn,active,stats}
  dealer:0,
  pot:0,
  sidePots:[],
  currentBet:0,
  minRaise:10,
  round:'idle',
  turnIndex:0,
  smallBlind:5,
  bigBlind:10,
  simIterations:1200,
  aiDifficulty:0.8,
  playerCount:2,
  handsPlayed: 0,
  lastAIBet: 0,
};

/* -------------------------
   UI Helpers
   ------------------------- */
const el = id => document.getElementById(id);
function log(msg, who='game'){
  const target = el('gameLog');
  const time = new Date().toLocaleTimeString();
  target.innerHTML = `<div>[${time}] ${msg}</div>` + target.innerHTML;
}
function renderChips(){
  el('potAmount').textContent = state.pot;
  el('handsPlayed').textContent = state.handsPlayed;
  el('simLabel').textContent = state.simIterations;
  el('roundName').textContent = state.round.charAt(0).toUpperCase() + state.round.slice(1);
  el('yourNet').textContent = (state.players.find(p=>!p.ai)?.stack || 0) - 1000;
  el('aiWins').textContent = state.players.filter(p=>p.ai && p.stats && p.stats.wins).length;
}

/* Build player UI */
function renderPlayers(){
  const row = el('playerRow'); row.innerHTML='';
  for(const p of state.players){
    const div = document.createElement('div'); div.className='player';
    const info = document.createElement('div'); info.className='info';
    info.innerHTML = `<div><strong>${p.name}${p.id===state.dealer?' (D)':''}</strong></div><div class="chips"><div class="chip">${p.stack}</div></div>`;
    div.appendChild(info);
    const handWrap = document.createElement('div'); handWrap.style.display='flex'; handWrap.style.gap='6px';
    for(const c of p.hand){
  const wrap = document.createElement('div');
  wrap.className = 'card-wrap';
  if(!p.ai || p.revealed) wrap.classList.add('revealed');

  const inner = document.createElement('div');
  inner.className = 'card-inner card small';

  const back = document.createElement('div');
  back.className = 'card-face card-back';
  back.textContent = '';

  const front = document.createElement('div');
  front.className = 'card-face card-front';
  front.textContent = c.code;

  inner.appendChild(back);
  inner.appendChild(front);
  wrap.appendChild(inner);

  if(p.folded) wrap.style.opacity = 0.4;

  handWrap.appendChild(wrap);
}

    div.appendChild(handWrap);
    const status = document.createElement('div'); status.className='small';
    status.textContent = p.folded ? 'Folded' : (p.allIn ? 'All-in' : (p.active ? 'Active' : 'Out'));
    div.appendChild(status);
    row.appendChild(div);
  }
}

/* Render community */
function renderCommunity(){
  const cont = el('community'); cont.innerHTML='';
  for(const c of state.community){
    const d = document.createElement('div'); d.className='card';
    d.textContent = c.code; cont.appendChild(d);
  }
}

/* -------------------------
   Game Flow
   ------------------------- */
function resetDeck(){ state.deck = shuffle(createDeck()); }
function initPlayers(count){
  state.players = [];
  for(let i=0;i<count;i++){
    const isHuman = (i===count-1); // last seat is human
    state.players.push({
      id:i,
      name: isHuman ? 'You' : `AI ${i+1}`,
      ai: !isHuman,
      stack:1000,
      hand:[],
      bet:0,
      folded:false,
      allIn:false,
      active:true,
      revealed:false,
      stats:{wins:0}
    });
  }
  // seat human at last index for consistent UI
  state.dealer = Math.floor(Math.random()*state.players.length);
}

function dealHole(){
  for(const p of state.players) p.hand=[];
  for(let r=0;r<2;r++){
    for(const p of state.players){
      p.hand.push(state.deck.pop());
    }
  }
}

function postBlinds(){
  const sbIdx = (state.dealer+1)%state.players.length;
  const bbIdx = (state.dealer+2)%state.players.length;
  const sb = Math.min(state.smallBlind, state.players[sbIdx].stack);
  const bb = Math.min(state.bigBlind, state.players[bbIdx].stack);
  state.players[sbIdx].stack -= sb; state.players[sbIdx].bet += sb; state.pot += sb;
  state.players[bbIdx].stack -= bb; state.players[bbIdx].bet += bb; state.pot += bb;
  state.currentBet = bb;
  log(`${state.players[sbIdx].name} posts small blind ${sb}`);
  log(`${state.players[bbIdx].name} posts big blind ${bb}`);
}

function resetBetsForRound(){
  for(const p of state.players){ p.bet=0; }
  state.currentBet = 0;
}

function activePlayers(){
  return state.players.filter(p=>!p.folded && p.stack>0);
}

function nextToAct(from){
  const n = state.players.length;
  for(let i=1;i<=n;i++){
    const idx = (from + i) % n;
    const p = state.players[idx];
    if(!p.folded && (p.stack>0 || p.bet>0)) return idx;
  }
  return null;
}

async function revealAIWinner(winner){
  winner.revealed = true;
  renderPlayers();
  await sleep(900);
}



/* Progress rounds */
async function progressRound(){
  if(state.round==='preflop'){
    // burn + flop
    state.deck.pop();
    state.community.push(state.deck.pop(), state.deck.pop(), state.deck.pop());
    state.round='flop';
    log('Dealt the flop.');
  } else if(state.round==='flop'){
    state.deck.pop(); state.community.push(state.deck.pop()); state.round='turn'; log('Dealt the turn.');
  } else if(state.round==='turn'){
    state.deck.pop(); state.community.push(state.deck.pop()); state.round='river'; log('Dealt the river.');
  } else if(state.round==='river'){
    state.round='showdown'; log('Showdown!');
    await showdown();
    return;
  }
  // reset bets for next betting round
  for(const p of state.players) p.bet=0;
  state.currentBet=0;
  renderCommunity(); renderPlayers(); renderChips();
  // first to act postflop is player after dealer
  state.turnIndex = (state.dealer+1)%state.players.length;
  await runBettingRound();
}

/* Betting round controller */
async function runBettingRound(){
  const acted = new Set();   // track who already acted
  let loopGuard = 0;

  while(true){
    loopGuard++; if(loopGuard > 50) break;

    const p = state.players[state.turnIndex];

    // skip folded / all-in players
    if(!p || p.folded || p.stack === 0){
      state.turnIndex = (state.turnIndex + 1) % state.players.length;
      continue;
    }

    // if this player already acted this round, stop
    if(acted.has(p.id)) break;

    // take action
    if(p.ai){
      await aiTurn(p);
    } else {
      await humanTurn(p);
    }

    acted.add(p.id);
    
    const active = state.players.filter(p=>!p.folded); if(active.length === 1){   const winner = active[0];   if(winner.ai){     await revealAIWinner(winner);   }   winner.stack += state.pot;   log(`${winner.name} wins ${state.pot} (all others folded)`);   state.pot = 0;   state.handsPlayed++;   await sleep(1000);   startHand();   return; }

    renderPlayers();
    renderChips();
    renderCommunity();

    // advance turn
    state.turnIndex = (state.turnIndex + 1) % state.players.length;

    // âœ… END CONDITION:
    // everyone who can act has acted once
    const remaining = state.players.filter(x =>
      !x.folded && x.stack > 0 && !acted.has(x.id)
    );

    if(remaining.length === 0) break;
  }

  // reset bets (pot already updated during actions)
  for(const p of state.players) p.bet = 0;
  state.currentBet = 0;

  await sleep(300);
  await progressRound();
}


/* Showdown & pot split (simple side-pot handling) */
async function showdown(){
  // reveal all hands
  for(const p of state.players){
  p.revealed = true;
  renderPlayers();
  await sleep(250);
}
 renderCommunity();
  await sleep(800);
  // Evaluate all active players
  const contenders = state.players.filter(p=>!p.folded);
  const results = contenders.map(p=>{
    const best = bestFrom(p.hand, state.community);
    return {player:p, best};
  });
  // sort by score
  results.sort((a,b)=>b.best.score - a.best.score);
  // naive pot split: award pot to top scorer(s) (doesn't fully implement side-pot math)
  const topScore = results[0].best.score;
  const winners = results.filter(r=>r.best.score===topScore).map(r=>r.player);
  const share = Math.floor(state.pot / winners.length);
  for(const w of winners){ w.stack += share; w.stats.wins = (w.stats.wins||0)+1; }
  log(`Showdown: ${results.map(r=>r.player.name+': '+r.best.name).join(' | ')}`);
  if(winners.length===1) log(`${winners[0].name} wins ${state.pot}`);
  else log(`Split pot ${state.pot} between ${winners.map(w=>w.name).join(', ')}`);
  state.pot = 0;
  state.handsPlayed++;
  // rotate dealer
  state.dealer = (state.dealer+1)%state.players.length;
  // reset for next hand
  for(const p of state.players){ p.bet=0; p.folded=false; p.allIn=false; p.revealed=false; }
  state.community=[];
  state.round='idle';
  renderPlayers(); renderChips(); renderCommunity();
  await sleep(1200);
  startHand();
}

/* -------------------------
   AI Logic
   - Monte Carlo with range sampling
   - Opponent modeling: aggression/fold tendencies
   ------------------------- */
function sampleOpponentRange(knownCards, iterations=1){
  // returns a random hole for opponent avoiding knownCards
  const deck = createDeck().filter(c=>!knownCards.some(k=>k.code===c.code));
  shuffle(deck);
  return [deck.pop(), deck.pop()];
}

function estimateWinProbMonteCarlo(hole, community, knownDeck, iterations=1200){
  // Monte Carlo: sample opponent hands and remaining community
  let wins=0, ties=0;
  const deckBase = knownDeck.slice();
  for(let it=0; it<iterations; it++){
    const d = deckBase.slice();
    shuffle(d);
    const opp = [d.pop(), d.pop()];
    const needed = 5 - community.length;
    const simComm = community.slice();
    for(let k=0;k<needed;k++) simComm.push(d.pop());
    const aBest = bestFrom(hole, simComm);
    const oBest = bestFrom(opp, simComm);
    if(aBest.score > oBest.score) wins++;
    else if(aBest.score === oBest.score) ties++;
  }
  return (wins + ties*0.5)/iterations;
}

async function aiTurn(p){
  // quick checks
  if(p.folded || p.stack===0) return;
  // compute toCall
  const toCall = state.currentBet - p.bet;
  // estimate win prob
  const known = state.community.concat(...state.players.flatMap(x=>x.hand));
  const winProb = estimateWinProbMonteCarlo(p.hand, state.community, state.deck.concat(known), Math.max(200, Math.floor(state.simIterations * state.aiDifficulty)));
  // pot odds
  const potOdds = toCall / (state.pot + toCall || 1);
  // decision thresholds tuned by difficulty
  const raiseThreshold = 0.7 * state.aiDifficulty;
  const callThreshold = 0.45 * state.aiDifficulty;
  // bluff chance
  const bluffChance = 0.05 + (1-state.aiDifficulty)*0.15;
  // decide
  if(winProb > raiseThreshold && p.stack > toCall){
    // raise
    const raiseAmt = Math.min(p.stack, Math.max(state.bigBlind, Math.floor(state.pot * (0.25 + winProb))));
    const total = Math.min(p.stack, toCall + raiseAmt);
    p.stack -= total;
p.bet += total;
state.pot += total;
state.currentBet = p.bet;
state.lastAIBet = total;   // ðŸ‘ˆ track AI bet
    log(`${p.name} raises to ${p.bet}`);
  } else if(winProb > callThreshold || potOdds < winProb){
    // call
    const amt = Math.min(toCall, p.stack);
    p.stack -= amt;
p.bet += amt;
state.pot += amt;
state.lastAIBet = amt;   // ðŸ‘ˆ track AI bet
    log(`${p.name} calls ${amt}`);
  } else {
    // maybe bluff or fold
    if(toCall===0 && Math.random() < bluffChance){
      const raiseAmt = Math.min(p.stack, Math.max(state.bigBlind, Math.floor(state.pot * 0.2)));
      p.stack -= raiseAmt;
p.bet += raiseAmt;
state.pot += raiseAmt;
state.currentBet = p.bet;
state.lastAIBet = raiseAmt;   // ðŸ‘ˆ track AI bet
      log(`${p.name} (bluff) raises to ${p.bet}`);
    } else {
      p.folded = true;
      log(`${p.name} folds`);
    }
  }
  // if player put all chips, mark allIn
  if(p.stack===0) p.allIn = true;
  await sleep(300 + randInt(300));
}

/* -------------------------
   Human actions (UI)
   ------------------------- */
let humanActionResolve = null;
function enableHumanControls(enable){
  el('foldBtn').disabled = !enable;
  el('callBtn').disabled = !enable;
  el('raiseBtn').disabled = !enable;
  el('betInput').disabled = !enable;
}
function humanFold(){
  const me = state.players.find(p=>!p.ai);
  me.folded = true; log('You fold'); humanActionResolve && humanActionResolve();
}

function humanCall(){
  const me = state.players.find(p=>!p.ai);

  // Call = match last AI bet
  const amt = Math.min(state.lastAIBet, me.stack);

  if(amt <= 0){
    log('You check');
    humanActionResolve && humanActionResolve();
    return;
  }
  me.stack -= amt;
  me.bet += amt;
  state.pot += amt;

  log(`You call ${amt}`);

  if(me.stack === 0) me.allIn = true;
  humanActionResolve && humanActionResolve();
}

function humanRaise(){
  const me = state.players.find(p=>!p.ai);
  const raiseVal = Math.max(parseInt(el('betInput').value||0), state.minRaise);
  const toCall = state.currentBet - me.bet;
  const total = Math.min(me.stack, toCall + raiseVal);
  me.stack -= total; me.bet += total; state.pot += total;
  state.currentBet = me.bet;
  log(`You raise to ${me.bet}`);
  if(me.stack===0) me.allIn=true;
  humanActionResolve && humanActionResolve();
}

async function humanTurn(p){
  // enable UI and wait for action
  enableHumanControls(true);
  renderPlayers(); renderChips();
  await new Promise(resolve=>{
    humanActionResolve = resolve;
  });
  humanActionResolve = null;
  enableHumanControls(false);
}

/* -------------------------
   Start / Reset Hand
   ------------------------- */
function startHand(){
  // remove players with zero stack? keep for now
  resetDeck();
  state.community=[];
  state.pot=0;
  state.sidePots=[];
  state.currentBet=0;
  state.round='preflop';
  // deal
  dealHole();
  // post blinds
  postBlinds();
  renderPlayers(); renderCommunity(); renderChips();
  // first to act is player after big blind
  state.turnIndex = (state.dealer+3)%state.players.length;
  runBettingRound();
}

/* -------------------------
   UI Wiring
   ------------------------- */
el('newGameBtn').addEventListener('click', ()=>{
  state.playerCount = parseInt(el('playerCount').value);
  initPlayers(state.playerCount);
  state.smallBlind = parseInt(el('smallBlind').value);
  state.bigBlind = parseInt(el('bigBlind').value);
  state.simIterations = parseInt(el('simIterations').value);
  state.aiDifficulty = parseFloat(el('aiDifficulty').value);
  // reset stacks
  for(const p of state.players){ p.stack = 1000; p.bet=0; p.folded=false; p.allIn=false; p.revealed=false; p.stats={wins:0}; }
  renderPlayers(); renderCommunity(); renderChips();
  startHand();
});

el('foldBtn').addEventListener('click', humanFold);
el('callBtn').addEventListener('click', humanCall);
el('raiseBtn').addEventListener('click', humanRaise);
el('simIterations').addEventListener('input', e=>{ state.simIterations = parseInt(e.target.value); el('simLabel').textContent = state.simIterations; });
el('smallBlind').addEventListener('input', e=>{ state.smallBlind = parseInt(e.target.value); });
el('bigBlind').addEventListener('input', e=>{ state.bigBlind = parseInt(e.target.value); });
el('playerCount').addEventListener('change', e=>{ /* no-op until new game */ });
el('aiDifficulty').addEventListener('change', e=>{ state.aiDifficulty = parseFloat(e.target.value); });

/* -------------------------
   Initialize default players and UI
   ------------------------- */
initPlayers(2);
renderPlayers();
renderCommunity();
renderChips();
log('Game ready. Click New Game to start or use current settings.');
</script>
</body>
</html>
